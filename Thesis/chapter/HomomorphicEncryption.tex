\chapter{Homomorphic Encryption}

Homomorphic encryption (HE) is a specialized cryptographic system that enables the execution of operations on encrypted data in a similar fashion to that of unencrypted data. This capability allows for the outsourcing of data storage and computation to external services while maintaining the confidentiality of the data. This creates a zero-trust environment, where there is no need to trust external providers as they are unable to decrypt the data. Furthermore, the occurrence of data breaches would be effectively eliminated, as the data is always encrypted.


As described in \cite{FheImplementations}, HE algorithms can be grouped into 3 classes:
\begin{description}
  \item [Partially Homomorphic Encryption (PHE)]\hfill \\one type of operation can be performed an unlimited amount of times
  \item [Somewhat Homomorphic Encryption (SWHE)]\hfill \\some types of operations for an limited number of times
  \item [Fully Homomorphic Encryption (FHE)]\hfill \\an unlimited type of operations for an unlimited amount of times
\end{description}

As the algorithm will be used on binary data, the operations are often reduced to addition and multiplication, as with these two, all other basic operations can be done in binary space.

The Idea was first developed by Rivest et al. \cite{Rivest1978} in 1978. They also proposed an PHE scheme, based on RSA., for multiplication only. More PHE schemes were developed over time and in 2009 C. Gentry proposed the first FHE scheme \cite{Gentry2009AFH} based on a bootstrapping technique, which refreshes the ciphertext, so that the internal errors are reduced and further calculations can be done. With that, all SWHE systems can be converted into FHE systems. However, the conversion results in a significant reduction in performance due to the computational intensity of the bootstrapping operation.

\section{The R-LWE SWHE Scheme}

In this section, the LWE scheme in its R-LWE version, as previously described, will be transformed into an SWHE scheme. To achieve this, the BFV scheme \cite{bfv} will be slightly modified to align with the equations previously used.

As already mentioned, the two operations, addition and multiplication, need to be implemented in the ciphertext space in order to create create an FHE scheme, as with these two all other operations can be created.

\subsection*{Addition}

The objective is to develop a method for adding encrypted messages in such a way that the result is identical to that obtained by adding the plaintext messages. This can be achieved by adding the ciphertext together, with the error increasing linearly. Further details on this approach can be found in reference \cite{bfv}. 

\begin{algorithm}[htb]
  \begin{algorithmic}[1]
    \REQUIRE $ct_1 = (u_1, v_2)$, $ct_2 = (u_2, v_2)$
    \RETURN $ct_{add} = ([u_1 + u_2]_q, [v_1 + v_2]_q)$
  \end{algorithmic}
  \caption{R-LWE: Addition}
  \label{alg:RlweAddition}
\end{algorithm}

The newly created $ct_{add}$ can then be used, like any other ciphertext, to be decrypted and used for other operations. However, it should be noted that the error in it has increased, which may result in the incorrect result being produced at some point.

\subsection*{Multiplication}

Doing the same with multiplication is a bit trickier. In order to simplify the following derivations and explanations, the following simplification is made, based on Algorithm \ref{alg: SampleLweDecryption}:

\begin{equation}
  ct(s)_q = v-s\cdot u
  \label{eq:baseCt}
\end{equation}

Also let $ct_1$ and $ct_2$ be two ciphertext that we want to use, with $ct_1(s) = v_1-s\cdot u_1$ and $ct_2(s) = v_2-s\cdot u_2$
When multiplying these two values together, the following equation is created:
\begin{equation}
  \begin{split}
    [ct_1(s)\cdot ct_2(s)]_q & = [(v_1-s\cdot u_1) \cdot (v_2-s\cdot u_2)]_q                                          \\
                         & = [v_1\cdot v_2 - v_1\cdot u_2 \cdot s- v_2\cdot u_1\cdot s + u_1\cdot u_2\cdot s^2]_q \\
                         & = [\underbrace{v_1\cdot v_2}_{v_m} - \underbrace{(v_1\cdot u_2 + v_2\cdot u_1)}_{u_m}\cdot s + \underbrace{u_1\cdot u_2\cdot}_{x_m} s^2]_q \\
                         & = [v_m - u_m\cdot s + x_m \cdot s^2]_q
  \end{split}
  \label{eq:ciphertextMultiplication}
\end{equation}

This creates three blocks, each depending on a different power of $s$. In comparison to Equation \ref{eq:baseCt}, that we now have a similar equation, just with the additional $x_m\cdot s^2$ factor. 
Now a way needs to be found to create an approximation of $x_m\cdot s^2$, which can be added to $v_m$ and $u_m$, in order to reduce the degree of the equation from 2 to 1. This process is called Relinearisation. The formalization can be seen in equation \ref{eq:relinFormalized}, where $r$ is an error, which should be as small as possible, as otherwise the decryption will not work.

\begin{equation}
  [v_m - u_m\cdot s + x_m \cdot s^2]_q = [v'_m - u'_m\cdot s + r]_q
  \label{eq:relinFormalized}
\end{equation}

In order to solve this problem, the "modulus switching" technique from \cite{bfv} will be used. The first step is to define an Relinearisation Key ($rlk$), which masks $s^2$. In this, the value $s^2$ will be multiplied with an new constant $p$. This constant is necessary to reduce the error that is generated when solving the rlk (see equation \ref{eq:RlkDecryption}).

\begin{algorithm}[htb]
  \begin{algorithmic}[1]
    \REQUIRE $s$
    \STATE $A \leftarrow R^d_{p \cdot q}$
    \STATE $e \leftarrow \chi_R^{'d}$
    \STATE $b = [A\cdot s+e+p\cdot s^2]_{p \cdot q}$
    \RETURN $rlk:=(A_{rlk}, b_{rlk})$
  \end{algorithmic}
  \caption{R-LWE: RLK Generation}
  \label{alg:RingRLKGeneration}
\end{algorithm}

The form of the masked is based on the public key, so when $A_{rlk}$ and $b_{rlk}$ are "decrypted" with $s$, the original value $p\cdot s^2$ is obtained.

With the help of the $rlk$, we can now compute two versions of $x_m\cdot s^2$, one which is added to $v_m$, called $xv_m$ and one that is added to $u_m$ called $xu_m$.

\begin{equation}
  (xu_m, xv_m) = (\left[\left\lfloor \frac{x_m \cdot A_{rlk}}{p}  \right\rceil \right]_q, \left[\left\lfloor \frac{x_m \cdot b_{rlk}}{p}  \right\rceil \right]_q )
\end{equation}

When "decrypting" these values (as seen in equation \ref{eq:RlkDecryption}), it can be seen that $x_m$, which is a random element in $R_q$ is multiplied with the error $e_{rlk}$. That would create a huge error value. Because of this, it is divided by $p$ to decrease the error. To still be able to create $x_m \cdot s^2$, $s^2$ was multiplied with $p$  in the $rlk$.

\begin{equation}
  \begin{split}
    xv_m + xu_m \cdot s &= \left[\left\lfloor \frac{x_m \cdot b_{rlk}}{p}  \right\rceil \right]_q - \left[\left\lfloor \frac{x_m \cdot A_{rlk}}{p}  \right\rceil \right]_q \cdot s \\
    &\approx \left[\frac{x_m \cdot b_{rlk}}{p} - \frac{x_m \cdot A_{rlk}}{p} \cdot s\right]_q \\
    &\approx \left[\frac{x_m \cdot (A_{rlk}\cdot s+e_{rlk}+p\cdot s^2)}{p} - \frac{x_m \cdot A_{rlk} \cdot s}{p}\right]_q \\
    &\approx \left[\frac{x_m \cdot A_{rlk}\cdot s}{p}+\frac{x_m \cdot e_{rlk}}{p}+\frac{x_m \cdot p\cdot s^2}{p} - \frac{x_m \cdot A_{rlk} \cdot s}{p}\right]_q \\
    &\approx \left[\frac{x_m \cdot e_{rlk}}{p}+ x_m \cdot s^2 \right]_q
  \end{split}
  \label{eq:RlkDecryption}
\end{equation}

The full algorithm for multiplying can be seen in Algorithm \ref{alg:RingMultiplication}. To make everything work, $\frac{t}{q}$ needs to be multiplied to the different factors, more detail on this can also be found in \cite{bfv}.

\begin{algorithm}[htb]
  \begin{algorithmic}[1]
    \REQUIRE $rlk=(A_{rlk}, b_{rlk})$, $ct_1 = (v_1, u_1)$, $ct_2 = (v_2, u_2)$
    \STATE $v_m = \left[\left\lfloor \frac{t}{q}\cdot (v_1 \cdot v_2)\right\rceil\right] _q $
    \STATE $u_m = \left[\left\lfloor \frac{t}{q}\cdot(v_1 \cdot u_2 + v_2 \cdot u_1)\right\rceil\right] _q$
    \STATE $x_m = \left[\left\lfloor \frac{t}{q}\cdot(u_1 \cdot u_2)\right\rceil\right] _q$
    \STATE $xu_m = \left[\left\lfloor \frac{x_m \cdot A_{rlk}}{p}  \right\rceil \right]_q$
    \STATE $xv_m = \left[\left\lfloor \frac{x_m \cdot b_{rlk}}{p}  \right\rceil \right]_q$
    \RETURN $ct_m:=(\left[u_m + xu_m\right]_q , \left[v_m + xv_m\right]_q )$
  \end{algorithmic}
  \caption{R-LWE: Multiplication}
  \label{alg:RingMultiplication}
\end{algorithm}

% Tasks:
% \begin{itemize}
%   \item Explain what it is in general
%   \item Show 1 or two homomorphic schemes, maybe one LWE and one R-LWE?: Useing BFV and BGV (see \cite{FheImplementations} Page 11)
%   \item Translate them into M-LWE. Should be not to hard, based on what is explained before
%   \item Define criteria to compare them