\chapter{M-LWE Comparison and Evaluation}

This chapter will now compare the the three different LWE schemes, with teh criteria discussed already in section \ref{sec:LweComparisonCriteria} and \ref{sec:HomomorphCriteria}. The first comparison will be based the size cost of the variables, that are created when running the schemes. Here some general formulars will be created to calculate the size and then some comparisons, based on real world values will be compared.

The second comparison will concentrate on the time cost of the algorithms for the different schemes. Here some general characteristics will be discussed first. \info{Complete after having written all tests}

\section{Size cost comparison}

The initial comparison will be the size in bits of the various output variables generated when working with the different schemes. The output is dependent on four variables: the matrix dimension $n$, the polynomial rank $d$, the number of bits of the modulus $q_b$ and the number of bits of the message $\ell$. In the case of Plain-LWE, the polynomial rank is equal to one, while in R-LWE, the matrix dimension is equal to one. In all other cases, the polynomial rank and matrix dimension are greater than one. The size of the different variables can be calculated based on the dimensions defined in Table \ref{table:LweKeys}. As the $rlk$ is essentially a modified private key, it has the same dimension; it is simply required $n$ times. All equations for computing the number of bits needed for the different variables for the schemes can be found in Table \ref{table:OutputVariableSize}. 

\begin{table}[h]
  \centering
  \caption{LWE output variable size in bits based on $n$, $d$, $q_b$ and $\ell$}
  \begin{tabular}{|l|c|c|c|}
    \toprule
          & Plain-LWE                       & R-LWE                                                        & M-LWE                                                               \\
    \midrule
    $sk$  & $n \cdot q_b$                   & $d \cdot q_b$                                                & $n \cdot d \cdot q_b$                                               \\
    $pk$  & $(n^2 +n) \cdot q_b$            & $2 \cdot (d \cdot q_b)$                                      & $(n^2 + n)\cdot d \cdot q_b$                                        \\
    $rlk$ & $n \cdot ((n^2 +n) \cdot q_b)$  & $2 \cdot (d \cdot q_b)$                                      & $n \cdot ((n^2 + n)\cdot d \cdot q_b)$                              \\
    $m$   & $\ell$                          & $\left\lceil \ell/d \right\rceil \cdot d$                    & $\left\lceil \ell/d \right\rceil \cdot d$                           \\
    $ct$  & $\ell \cdot((n + 1) \cdot q_b)$ & $\left\lceil \ell/d \right\rceil \cdot(2 \cdot d \cdot q_b)$ & $\left\lceil \ell/d \right\rceil \cdot ((n + 1) \cdot d \cdot q_b)$ \\
    \bottomrule
    
  \end{tabular}
  \label{table:OutputVariableSize}
\end{table}

To provide a more intuitive understanding of the differences between the various schemes, a simulation of the values can be observed in Figure \ref{fig:OutputFactors}. The development of the number of factors is plotted for the different schemas based on $n$ and $d$. The number of factors is equivalent to the equations in Table \ref{table:OutputVariableSize} if $q_b=1$. This is equivalent to the number of factors that need to be stored for the output variable. If a larger modulus is used, the number of factors can be multiplied by it, thereby determining the total number of storage in bits that is required. For $m$ and $ct$ a value of $l=64$ was chosen, to reflect different properties. In the case of P-LWE, the matrix dimension, $n$, is plotted against the number of factors. In contrast, for R-LWE, the polynomial rank, $d$, is plotted against the number of factors. Given that M-LWE relies on two variables, namely $n$ and $d$, it was decided that the best approach would be to plot $n$ against the number of factors, with multiple lines representing different values of $d$. This was done to simplify the visualization of the differences, as a three-dimensional plot is more challenging to comprehend, particularly when printed in two dimensions. Additionally, the value of $d$ is always linear in relation to the number of factors, indicating that it solely affects the slope of the change in $n$, as evidenced in the plot.


\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.52]{images/OutputFactors.png}
  \caption[Output Variable Factors by Scheme]{The development of factors for the various output variables by schema. Each of the 3 columns of plots is for one scheme. Plain-LWE and M-LWE use $n$ for the x-axis, R-LWE uses $d$. The y-axis is for all plots the calculated number of factors. For M-LWE, the different line types indicate different values of $d$. The message length $l=64$}
  \label{fig:OutputFactors}
\end{figure}

The growth rates observed for the secret key $sk$ are linear with regard to the variables $n$ and $d$ for Plain-LWE and R-LWE, respectively. In contrast, M-LWE exhibits a linear relationship with either $n$ or $d$. When both variables grow simultaneously, the growth rate becomes quadratic. As a consequence, the growth rate for the number of factors in this case exhibits a significantly higher rate of increase than that observed for the other two schemes.

The linear growth rate observed for R-LWE remains constant for both the private key $pk$ and the relinearization key $rlk$. In contrast, the growth rates for the other two schemes exhibit a significant increase, particularly with regard to the matrix dimension $n$. For $pk$, the growth rate is quadratic, while for $rlk$, it is even cubic. When increasing the polynomial rank simultaneously, the growth rate for M-LWE becomes cubic or quartic, respectively.

It should be noted that there is a slight caveat associated with the message and the ciphertext in the context of R-LWE and M-LWE. Due to their simultaneous encryption of multiple bits, there is a possibility of either over- or undershooting the necessary amount. This phenomenon can be observed in the plots for the output variables $m$ and $ct$, with the message length $l$ set to $64$ bits. In contrast to L-LWE, where the number of factors for $m$ is constant, as each bit is treated separately, the number of factors needed for R-LWE and M-LWE depends on the polynomial rank $d$. In the event that the length of the message, denoted by $l$, exceeds the degree of the polynomial, it is necessary to create a multitude of polynomials of degree $d$ in order to encrypt the entire message. If the length of the message, represented by $l$, is not evenly divisible by the polynomial rank, $d$, an additional polynomial must be created and padded. Conversely, if the length of the message is smaller than the polynomial rank, the message will fit into one polynomial, but the extra size must be padded. This is why the number of factors initially remains at 64 and then begins to increase, as the polynomial is too large for the message, resulting in wasted space.

Apart from this, the scaling of the number of factors is linear with respect to the dimension variables, namely $n$ and $d$. Consequently, for R-LWE, the number of factors is identical to that of the private key $pk$ and the relinearization key $rlk$ when $d$ is equal to or greater than $l$. In all other cases, the number of factors is a multiple of this value, dependent on the number of polynomials that must be created to fit the message. In the case of M-LWE and Plain-LWE, the number of factors is comparable to that of the secret key, $sk$. However, in the case of M-LWE, a similar situation arises with R-LWE, whereby the number of factors required can be a multiple based on the size of $d$. In the case of Plain-LWE, the increase is significantly more pronounced, as each bit must be encrypted individually, resulting in the generation of a distinct ciphertext for every bit.

In general, R-LWE requires the fewest number of factors and the smallest amount of physical space to store its output variables. In comparison, Plain and especially M-LWE require a greater number of factors and a greater amount of physical space. Furthermore, the growth rate for R-LWE is significantly lower than that of Plain and M-LWE. In defense of M-LWE, it should be noted that in practice the matrix dimension $n$ is quite small. In the CRYSTALS-Kyber scheme \cite{CyrstalsKyber}, the values are set between 2, which corresponds to low security, and 4, which corresponds to high security. This can be achieved because the security of the system is not solely dependent on the matrix, but also on the polynomials. In contrast to Plain-LWE, significantly larger values of $n$ are required for security. In the Frodo encryption scheme \cite{frodo}, which utilize Plain-LWE, values between $352$ for low security and $864$ for high security and a value of $n=752$ is recommended. This results in the number of factors exceeding $400$ million just for the $rlk$.

A comparison of the physical space required for the various encryption schemes, with variables based on the regular/recommended security level of published encryption schemes that employ the underlying method, can be found in Table \ref{table:OutputVariableInKB}. It is important to note that the results should be interpreted with caution and that direct comparisons between the numbers are not possible. However, the data provides a general indication of the differences between the schemes. Notably, the variables for Plain-LWE are considerably larger than those for the other two, requiring nearly 800 megabytes, solely for the RLK. Even when the ciphertext $ct$ is the smallest, this amount of disk space is necessary for each bit, whereas R-LWE and M-LWE can store 512 or 256 bits, respectively, with a slightly larger $ct$. With the exception of the ciphertext, R-LWE has the smallest overall size for every variable. However, as it can store twice the information of M-LWE and, as previously mentioned, 512 times more than Plain-LWE, it requires the smallest amount per bit stored.

\begin{table}[h]
  \centering
  \caption{LWE Output Variable size in Kilobyte (KB), based on variables for the regular/recommended security level of published encryption schemes}
  \begin{tabular}{|l|c||c|c|c|c||c|c|c|c|}
    \toprule
              & Source                      & $n$   & $d$   & $q$      & $q_b$ & $sk$    & $pk$      & $rlk$    & $ct$    \\
    \midrule
    Plain-LWE & \cite{frodo}                & $752$ &       & $32767$ & $15$  & $1.41$  & $1061.73$ & $798421$ & $1.412$ \\
    R-LWE     & \cite{PracticalKeyExchange} &       & $512$ & $25.601$ & $15$  & $0.96$  & $1.92$    & $1.92$   & $1.92$  \\
    M-LWE     & \cite{CyrstalsKyber}        & $3$   & $256$ & $7681$   & $13$  & $1.248$ & $4.992$   & $14.976$ & $1.664$ \\
    \bottomrule
  \end{tabular}
  \label{table:OutputVariableInKB}
\end{table}

In conclusion, the comparison based on the size of the output values indicates that R-LWE has the slowest growth of physical space needed based on its dimension variables. Although M-LWE has the fastest growth rate, as it is based on multiple dimension variables, this makes it far more secure than Plain-LWE. Consequently, the dimensions can be smaller in general to achieve a similar level of security, which results in a smaller physical size of its output variables. In terms of storage requirements for the output variables, Plain-LWE is by far the most demanding, with M-LWE requiring more physical space than R-LWE. However, the difference in these requirements is not as significant as that observed in the comparison with Plain-LWE.

\section{Time cost comparison}

The objective of this section is to perform a comparative analysis of the runtime performance of the algorithms with respect to a selected set of input parameters. To minimize the impact of noise, multiple iterations of each algorithm were executed with the specified inputs, and the median time value in seconds was calculated. In total, there are four parameters that can be manipulated: the dimensions $n$ and $d$, as well as the modulus values $q$ and $p$. To simplify the analysis of multiple variables and enhance the visualization of the differences, two performance tests were conducted. One test was conducted with varying dimension variables $n$ and $d$, while the modulus values $q$ and $p$ were constant. The second test was performed with the variables $n$ and $d$ fixed while the modulus values $q$ and $p$ were allowed to vary. This should provide a more straightforward means of illustrating the impact of these variables on the performance of the algorithms. The algorithms that are evaluated are the \textit{KeyGen} (Algorithm \ref{alg:HomomorphKeyGen}), the \textit{Encryption} (Algorithm \ref{alg: SampleLweEncryption}), the \textit{Decryption} (Algorithm \ref{alg: SampleLweDecryption}), the \textit{Addition} (Algorithm \ref{alg:MlweAddition}) and the \textit{Multiplication} (Algorithm \ref{alg:moduleMultiplication}).

The initial comparison is that of processing time, based on the two size dimensions, namely, $n$ and $d$. The results of the comparative analysis of the algorithms' performance are presented in Figure \ref{fig:nd-performance}. 

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.5]{images/nd-performance.png}
  \caption[Performance of the HE algorithms by $n$ and $d$]{Performance of the main algorithms in regard to dimensions $n$ and $d$ and the time in seconds. Each row is a different function, as stated always above the left plot. The left column plots the time against $n$ for some $d$ values. The right column plots the time against $d$ for some $n$ values.}
  \label{fig:nd-performance}
\end{figure}

In the figure, Plain-LWE is illustrated in the left column, in the line representing $d=1$, and R-LWE is shown in the right column with $n=1$. All other lines represent distinct versions of M-LWE. It can be observed that the \textit{KeyGen} and \textit{Multiplication} algorithms are the most time-consuming. Regardless of whether $n$ or $d$ is increased, these algorithms exhibit an exponential growth in time cost. However, the rate of increase for $d$ is relatively modest, in contrast to the significant rise observed in the case of $n$. This exponential growth can be attributed to the fact that, in order to perform matrix multiplication, the number of scalar multiplications increases quadratically. One potential solution to this issue is the use of dedicated matrix multiplication hardware, which performs the entire operation in a single step, or the incorporation of other optimized libraries. In order to work with numbers greater than 64 bits, it was not feasible to utilize the aforementioned libraries in the implemented system. Consequently, arbitrary-size integers in pure Python were employed, which yielded the observed outcomes. This provides an explanation as to why the increase of $n$ results in exponential Growth, but also demonstrates that this phenomenon occurs at a slower rate when $d$ is increased. The rationale behind this approach is that, in order to perform polynomial multiplication, the methodology outlined in Section \ref{sec:PolyMulMath} was employed, which translates polynomial multiplication into matrix-vector multiplication. As the value of $d$ increases, the dimensions of the matrix also increase, resulting in a quadratic growth in the number of multiplications required, following the same pattern previously described. The combination of these two facts also explains why the growth for $n$ is more pronounced. In addition to the increase in the number of polynomial multiplications due to the larger dimensions, each new polynomial multiplication also exhibits a quadratic runtime.
As the number of matrix multiplications increases, the algorithms become less efficient, exhibiting a decline in speed. This phenomenon is most evident in the \textit{KeyGen} and \textit{Multiplication}, where a single matrix multiplication is required for each $rlk$, which increases linearly with $n$. Consequently, these algorithms are quite slow. The \textit{Encryption} algorithm requires only a single matrix-vector and one vector-vector multiplication, resulting in a quadratic growth rate. This makes it significantly faster than the previously mentioned algorithms. In contrast, \textit{Addition} does not require any multiplication, making it the fastest algorithm by far. As only vectors need to be added, the time growth is also linear, as the number of additions scales linearly with the size of the vectors. With the \textit{Decryption}, there is a very interesting pattern. While the runtime scales linearly with the increase of $n$, it has a quadratic growth with the increase of $d$. This is due to the quadratic scaling of the matrix required for the polynomial multiplication, as previously explained. 




% Explain the growth rate based on the formulars

% \section{Comparison of the multiplicative and additive depth}

% https://eprint.iacr.org/2011/277 Hier stehen sachen zur fehlernetwicklung von Addition und Multiplikation drin (seite 3 oben). Kann evtl praktisch sein, da man die tests theoretisch untermauern kann.

% \begin{figure}[ht!]
%   \centering
%   \includegraphics[scale=0.35]{images/MultiplicativeDepth.png}
%   \caption[Multiplicative Depth by $n$ and $d$]{The Multiplicative Depth for $n$ and $d$ by $q$}
%   \label{fig:MultiplicativeDepth}
% \end{figure}